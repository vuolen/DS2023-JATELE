<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <title>JATELE</title>
  </head>
  <body>
    <h1>JATELE</h1>
    <textarea readonly></textarea>
    <input type="text" placeholder="Enter your message here..." />
    <div id="debug"></div>
  </body>
  <script>
    const textarea = document.querySelector("textarea");
    const input = document.querySelector("input");
    const debug = document.querySelector("#debug");
    let clients = {};

    const randomTimeout = () => Math.random() * 1000 + 3000;

    let raft = {
      log: [],
    };

    const raftElectionTimeout = () => {
      console.log("Election timeout, promoting to candidate", raft);

      raft.state = "candidate";
      raft.term++;
      raft.votedFor = peer.id;
      raft.timeout = setTimeout(raftElectionTimeout, randomTimeout());
      raftVoteReceived();

      Object.entries(clients).forEach(([id, conn]) => {
        conn.send({
          type: "REQUEST_VOTE",
          // TODO log index and term
          term: raft.term,
        });
      });
    };

    const raftConvertToFollower = (term) => {
      raft.state = "follower";
      raft.term = term;
      raft.votedFor = null;
      raft.votesReceived = 0;
      clearTimeout(raft.timeout);
      raft.timeout = setTimeout(raftElectionTimeout, randomTimeout());
    };

    raftConvertToFollower(0);

    const raftVoteReceived = () => {
      raft.votesReceived++;
      if (raft.votesReceived > Object.keys(clients).length / 2) {
        console.log("Promoting to leader", raft);
        raft.state = "leader";
        raft.votesReceived = 0;
        clearTimeout(raft.timeout);
        // TODO send heartbeat
      }
    };

    const raftSendAppendEntries = () => {
      Object.entries(clients).forEach(([id, conn]) => {
        conn.send({
          type: "APPEND_ENTRIES",
          // TODO log index and term
          term: raft.term,
          entries: [],
        });
      });
    };

    raft.timeout = setTimeout(raftElectionTimeout, randomTimeout());

    const keepActive = (id) => {
      fetch("http://localhost:3000/active", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ id }),
      });
    };

    const getClients = () => {
      fetch("http://localhost:3000/", {
        headers: {
          "Content-Type": "application/json",
        },
      }).then((res) =>
        res.json().then((data) => {
          data.clients.forEach((id) => {
            if (!clients[id] && id !== peer.id) {
              clients[id] = connect(id);
            }
          });

          Object.keys(clients).forEach((id) => {
            if (!data.clients.includes(id)) {
              clients[id].close();
              delete clients[id];
            }
          });
        })
      );
    };

    const initConnection = (conn) => {
      conn.on("data", (message) => {
        console.log(conn.peer, message);

        if (message.type === "REQUEST_VOTE") {
          // TODO, check log index and term
          if (message.term < raft.term) {
            conn.send({
              type: "REQUEST_VOTE_RESPONSE",
              term: raft.term,
              voteGranted: false,
            });
          } else if (raft.votedFor === null || raft.votedFor === conn.id) {
            console.log("Voting for", conn.id);
            raft.votedFor = conn.id;
            conn.send({
              type: "REQUEST_VOTE_RESPONSE",
              term: raft.term,
              voteGranted: true,
            });
          } else {
            conn.send({
              type: "REQUEST_VOTE_RESPONSE",
              term: raft.term,
              voteGranted: false,
            });
          }
        } else if (message.type === "REQUEST_VOTE_RESPONSE") {
          if (message.term > raft.term) {
            raftConvertToFollower(message.term);
          } else if (message.voteGranted) {
            raftVoteReceived();
          }
        } else if (message.type === "APPEND_ENTRIES") {
          if (message.term < raft.term) {
            conn.send({
              type: "APPEND_ENTRIES_RESPONSE",
              term: raft.term,
              success: false,
            });
          } else if (raft.state === "candidate") {
            raftConvertToFollower(message.term);
          }
          // TODO Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)
        } else if (message.type === "APPEND_ENTRIES_RESPONSE") {
          // TODO
        } else {
          addToTextArea(conn.peer + ": " + message);
        }
      });

      conn.on("error", (err) => {
        console.error(conn.peer, err);
        conn.close();
      });

      conn.on("close", () => {
        console.info(conn.peer, "Connection closed");
        conn.close();

        delete clients[conn.peer];
      });
    };

    const connect = (id) => {
      let connection = peer.connect(id);
      console.log("Connecting to ", id);

      connection.on("open", () => {
        console.info("Connected to ", id);

        initConnection(connection);
      });

      return connection;
    };

    const peer = new Peer(null, {
      host: "localhost",
      port: 3000,
      path: "/peer",
      iceServers: [],
    });

    peer.on("open", async (id) => {
      console.log("My peer ID is: " + id);

      keepActive(id);
      setInterval(() => keepActive(id), 5000);

      getClients();
    });

    peer.on("connection", (conn) => {
      console.info("Connection received from ", conn.peer);
      clients[conn.peer] = conn;

      initConnection(conn);
    });

    setInterval(() => {
      debug.innerHTML = "My ID" + peer.id + "<br>";
      debug.innerHTML += peer.open ? "PeerJS open" : "PeerJS closed";
      debug.innerHTML += "<br>Connections " + peer._connections.size;
      debug.innerHTML += "<br>Event count " + peer._eventsCount;
    }, 500);

    const addToTextArea = (text) => {
      textarea.value += "\n" + text;
      textarea.scrollTop = textarea.scrollHeight;
    };

    input.addEventListener("keyup", (e) => {
      if (e.key === "Enter" && input.value.length > 0) {
        addToTextArea(input.value);
        Object.entries(clients).forEach(([id, client]) => {
          client.send(input.value);
        });
        input.value = "";
      }
    });
  </script>
  <style type="text/css">
    body {
      display: flex;
      flex-direction: column;
    }
    textarea {
      height: 40vh;
    }
    input {
      padding: 5px;
    }
  </style>
</html>
